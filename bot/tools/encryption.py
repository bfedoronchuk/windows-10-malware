from cryptography.fernet import Fernet
from random import choice
from string import ascii_lowercase, ascii_uppercase, digits
from ast import literal_eval


_hiding_string_length = 10  # length of randomly generated string to hide digit of key length


def _generate_random_str(length) -> str:
    return ''.join(choice(ascii_lowercase + ascii_uppercase + digits) for i in range(length))


def encrypt(value: str) -> str:
    if value is None or value == '':
        return ''
    key: bytes = Fernet.generate_key()
    fernet = Fernet(key)
    encrypted_value: bytes = fernet.encrypt(value.encode('utf-8'))

    length_digits = list(str(len(key)))
    if len(length_digits) != 2:
        return ''
    string_hiding_length = ''.join(_generate_random_str(_hiding_string_length - 1) + digit for digit in length_digits)

    # since key length is 32, base64 representation will contain only one '=' character in the end
    stripped_key = key.decode('utf-8').rstrip('=')
    # note that value has predictable part in the start with timestamp which is slightly changed over the time
    encrypted_value_str = encrypted_value.decode('utf-8')
    return string_hiding_length + stripped_key + encrypted_value_str


def decrypt(encrypted_value: str) -> str:
    if encrypted_value is None or encrypted_value == '':
        return ''

    string_hiding_digits = encrypted_value[:_hiding_string_length * 2]
    first_digit = string_hiding_digits[_hiding_string_length - 1]
    second_digit = string_hiding_digits[_hiding_string_length * 2 - 1]
    key_len = int(first_digit + second_digit)

    key_start_index = _hiding_string_length * 2
    key_end_index = key_start_index + key_len - 1
    key = encrypted_value[key_start_index: key_end_index] + '='

    value = encrypted_value[key_end_index:]

    fernet = Fernet(key)
    return fernet.decrypt(value.encode('utf-8')).decode('utf-8')


def encrypt_dictionary(value: dict) -> str:
    if not value:
        return ''
    str_value = str(value)
    return encrypt(str_value)


def decrypt_dictionary(encrypted_value: str) -> dict:
    if not encrypted_value:
        return {}
    try:
        value = decrypt(encrypted_value)
        return literal_eval(value)
    except:
        return {}


def _test():
    test_value = {'xmppsender': 'arman@xmpp.is', 'xmpppass': 'F#ckxmpp69!', 'xmpprecipient': 'init6@jabb3r.org'}
    encrypted_value = encrypt_dictionary(test_value)
    print(encrypted_value)

    print('========================')

    decrypted_value = decrypt_dictionary(encrypted_value)
    print(type(decrypted_value))
    print(decrypted_value)
    print(decrypted_value['xmppsender'])


if __name__ == '__main__':
    _test()
